import { toast } from 'sonner';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Answer } from '@/feature/sectors/types';
import { client } from '@/lib/hono';

// Get company data and ID from local storage
function getCompanyDataFromStorage() {
  if (typeof window === 'undefined') return null;

  // Try to get company data from storage
  const companyData = localStorage.getItem('ZUMA_COMPANY_DATA');
  if (companyData) {
    try {
      const parsedData = JSON.parse(companyData);

      if (parsedData.id) {
        const id = parseInt(parsedData.id);
        if (!isNaN(id) && id > 0) {
          return { id, data: parsedData };
        }
      }
    } catch (error) {
      console.error('Error parsing company data from localStorage:', error);
    }
  }

  return null;
}

// Convert answer value to database enum value
function mapAnswerValueToDbValue(value: string) {
  const valueMap: Record<string, 'si' | 'no' | 'no_aplica' | 'en_proceso'> = {
    Si: 'si',
    No: 'no',
    'No Aplica': 'no_aplica',
    'En proceso': 'en_proceso'
  };
  return valueMap[value] || 'no';
}

// Function to find or create a question via API
async function findOrCreateQuestionViaApi(question: any) {
  try {
    // First try to find the question by actionId
    const searchResponse = await client.api['survey-questions']['$get']({
      query: { question: question.question }
    });

    if (!searchResponse.ok) {
      throw new Error('Failed to search for question');
    }

    const searchResult = await searchResponse.json();

    // If question exists, return its ID
    if (searchResult.data && searchResult.data.length > 0) {
      return searchResult.data[0].id;
    }

    // If not found, create the question
    const createResponse = await client.api['survey-questions']['$post']({
      json: {
        // Note: We don't include id as it's auto-generated by the database
        sectorId: question.sector_id,
        sector: question.sector,
        type: question.type,
        ndcMeasurement: question.ndc_measurement,
        initiative: question.initiative,
        odsId: question.ods_id,
        ods: question.ods,
        odsGoal: question.ods_goal,
        odsUrlImage: question.ods_url_image,
        actionId: question.id_actions,
        action: question.actions,
        indicatorName: question.name_indicator,
        indicatorEquation: question.equation_indicator,
        indicatorFrequency: question.frequency_indicator,
        indicatorRecommendedGoal: question.recommended_goal_indicator,
        ghgEmissionsReductionTarget:
          question.ghg_emissions_reduction_target_2030_tco2eq,
        coBenefits: question.co_benefits,
        question: question.question
      }
    });

    if (!createResponse.ok) {
      console.error('Error creating question:', await createResponse.text());
      throw new Error('Failed to create question');
    }

    const createResult = await createResponse.json();
    return createResult.data.id;
  } catch (error) {
    console.error('Error finding or creating question:', error);
    throw error;
  }
}

export function useCreateSurveyResponse(
  sectorId: number,
  surveyType: 'adaptacion' | 'mitigacion'
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      answers,
      questions,
      score
    }: {
      answers: Answer[];
      questions: any[];
      score: number;
    }) => {
      // Get company data from local storage
      const companyInfo = getCompanyDataFromStorage();

      if (!companyInfo || !companyInfo.id) {
        throw new Error(
          'No company information found. Please complete your company profile first.'
        );
      }

      try {
        // 1. Create the survey response header
        const headerData = {
          companyId: companyInfo.id,
          surveyType: surveyType,
          sectorId: sectorId,
          status: 'submitted' as const, // Use const assertion to match enum type
          // The schema expects either a Date object or null, not a string
          submittedAt: null, // Set to null for now, the server will handle this
          notes: `Score: ${score}`
        };

        const headerResponse = await client.api['survey-response-headers'][
          '$post'
        ]({
          json: headerData
        });

        if (!headerResponse.ok) {
          const errorText = await headerResponse.text();
          console.error('Error creating survey header:', errorText);
          throw new Error(`Failed to create survey header: ${errorText}`);
        }

        const headerResult = await headerResponse.json();

        if (!headerResult.data || !headerResult.data.id) {
          throw new Error('Invalid response from API: missing header ID');
        }

        const headerId = headerResult.data.id;

        // 2. Process each answer and create response items

        // Create a Map to track processed questions to avoid duplicates
        // The key is the action ID (id_actions) and the value is the database question ID
        const processedQuestions = new Map<number, number>();

        // First, find or create all questions to get their IDs
        for (const question of questions) {
          try {
            const questionId = await findOrCreateQuestionViaApi(question);
            processedQuestions.set(question.id_actions, questionId);
          } catch (error) {
            console.error(
              `Error processing question for action ID ${question.id_actions}:`,
              error
            );
          }
        }

        // Now process each answer with the correct question IDs
        for (const answer of answers) {
          // Find the corresponding question from the questions array
          const question = questions.find(
            (q) => q.id_actions === answer.questionId
          );
          if (!question) {
            console.warn(
              `Question not found for action ID: ${answer.questionId}`
            );
            continue;
          }

          // Get the database question ID from our map using the action ID
          const questionId = processedQuestions.get(answer.questionId);
          if (!questionId) {
            console.warn(
              `Database question ID not found for action ID: ${answer.questionId}`
            );
            continue;
          }

          // Create the response item
          const itemData = {
            headerId: headerId,
            questionId: questionId,
            value: mapAnswerValueToDbValue(answer.value),
            notes: null
          };

          try {
            const itemResponse = await client.api['survey-response-items'][
              '$post'
            ]({
              json: itemData
            });

            if (!itemResponse.ok) {
              const errorText = await itemResponse.text();
              console.error('Error creating survey response item:', errorText);
              console.warn('Continuing with other answers...');
              // Continue with other answers instead of failing completely
            } else {
              const itemResult = await itemResponse.json();
            }
          } catch (error) {
            console.error('Exception creating survey response item:', error);
            console.warn('Continuing with other answers...');
          }
        }

        return { headerId, score };
      } catch (error) {
        console.error('Error saving survey response:', error);
        throw error;
      }
    },
    onSuccess: () => {
      toast.success('Encuesta guardada exitosamente');
      queryClient.invalidateQueries({
        queryKey: ['surveyResponseHeaders', 'surveyResponseItems']
      });
    },
    onError: (error) => {
      console.error('Error saving survey response:', error);
      toast.error(
        'Error al guardar la encuesta: ' +
          (error instanceof Error ? error.message : 'Error desconocido')
      );
    }
  });
}
